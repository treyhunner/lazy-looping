<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Lazy Looping</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Lazy Looping</h1>
          <h2>The Next Iteration</h2>
          <p>
          <small><a href="https://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            - My name is Trey
            - If you write Python code for a living...
          </aside>
        </section>

        <section>
            <a href="http://pythonmorsels.com"><img src="morsels-logo.svg" class="no-style" alt="Python Morsels" style="max-height: 50vh;"></a>
          <aside class="notes" data-markdown>
            - ...you might want to try out a service I run called, Python Morsels...
            - sign up, choose your skill level: novice, intermediate, or advanced... and you'll learn something you didn't know about Python every week
          </aside>
        </section>

      </section>

      <section>

      <section>
        <h2 class="fragment">Problem</h2>
        <aside class="notes" data-markdown>
          - We're going to very quickly start **(click)** with a problem
        </aside>
      </section>

      <section>
        <h3 class="fragment">Find logged errors (with context)</h3>
        <pre class="python"><code data-trim data-noescape>
with open('logs.txt') as log_file:
    prev = line = None
    for next in log_file:
        next = next.rstrip('\n')
        if line and 'error' in line.lower():
            print(prev, line, next, sep='\n')
        prev, line = line, next
    if line and 'error' in line.lower():
        print(prev, line, None, sep='\n')
        </code></pre>
        <aside class="notes" data-markdown>
          - This code finds lines in a log file that contain errors **(click)**
          - ... but it prints out, not just the error line, but also the line just before the error and the line just after it...
          - We're going to look at this code later
          - For now, you should forget about it
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h2 class="fragment current-visible" data-fragment-index=1>Lazy Looping</h2>
        <h3><span class="fragment" data-fragment-index=4>What are </span><span class="fragment" data-fragment-index=2>iterables</span><span class="fragment" data-fragment-index=3> and iterators</span><span class="fragment" data-fragment-index=4>?</span></h3>
        <h3><br></h3>
        <aside class="notes" data-markdown>
          - When we *do* refactor that code later, we're going to use lazy looping **(click)**
          - ... which is all about iterables **(click)** and iterators **(click)**
          - so we need to define **(click)** what iterables and iterators are...
        </aside>
      </section>

      <section>
        <h3>Iterable</h3>
        <p class="fragment">An iterable is anything you can loop over.</p>
        <pre class="python fragment"><code data-trim data-noescape>
for thing in <span class="fragment bold-current">my_iterable</span>:
    do_something_with(thing)
        </code></pre>
        <aside class="notes" data-markdown>
          - An iterable is **(click)** anything that you can loop over
          - lists, tuples, files: lots of things are *iterables*
          - If you can write **(click)** a `for` loop to **iterate** over something, it is, by definition, an iterable **(click)**
          - So we kind of already *know* what iterables are, but what are iterators?
        </aside>
      </section>

      <section>
        <h3>Iter<span class="fragment bold-current" data-fragment-index=1>ator</span></h3>
        <span class="fragment" data-fragment-index=2></span>
        <p class="fragment" data-fragment-index=3><span class="fragment strike" data-fragment-index=6>The thing that powers iterables</span></p>
        <p class="fragment" data-fragment-index=4><span class="fragment bold-current" data-fragment-index=7>A special kind of "lazy" iterable</span></p>
        <aside class="notes" data-markdown>
          - iter-*ators* **(click)** are a bit more complicated than iter-*ables* **(click)**
          - ...
          - There are two definitons of iterators:
            - First: Iterators are the objects that powers all iteration in Python **(click)**
            - Second: they're a kind *lazy* iterable **(click)** which is *consumed* as you loop over
          - We're going to ignore that first definition. **(click)**  It's outside of the scope of this talk
          - We're going to focus on using **(click)** iterators as **lazy iterables**
          - If you *are* interested in that first definition...
        </aside>
      </section>

      <section data-background="#ffffff">
        <div class="fragment">
        <h1>Loop Better</h1>
        <h4>a deeper look at iteration in Python</h4>
        <p>
        <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
        </p>
        </div>
        <aside class="notes" data-markdown>
          - ... you can watch another talk of mine, called Loop Better **(click)**
          - In it I talk about how `for` loops work under the hood in Python and a bunch of other stuff that's outside the scope of this talk today...
        </aside>
      </section>

      <section>
        <h3 class="fragment" data-fragment-index=2>Files are iterators</h3>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>my_file = open("my_file.txt")
>>> </span><span class="fragment" data-fragment-index=3>next(my_file)
'This is line 1 of the file'
>>> </span><span class="fragment" data-fragment-index=4>next(my_file)
<span class="fragment bold-current" data-fragment-index=8>'This is line 2 of the file'</span>
>>> </span><span class="fragment" data-fragment-index=5>for line in my_file:
...     print(line, end="")
...
</span><span class="fragment" data-fragment-index=6><span class="fragment bold-current" data-fragment-index=7>This is line 3 of the file</span>
This is line 4 (the end of the file)
>>> </span><span class="fragment" data-fragment-index=9>list(my_file)</span><span class="fragment" data-fragment-index=10>
[]</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - *This* is one example of an iterator. **(click)** In Python, **file objects** *are iterators* **(click)**
          - You've probably worked with files in Python but you probably didn't know that they're iterators...
          - I'm going to use this file to show you the two things that we can do with *all* iterators...
            - We can pass them to the `next` function **(click)**, which gives us the *next* item in them... with files that's **(click)** the next line in the file
            - The other thing we can do with iterators is loop over them **(click)**: just like an other iterable
          - But the things in iterators get *consumed* as you loop over them **(click)**
          - So if you start getting items from them, and then you *stop*... the **(click)** next time you *start* again, you'll be right where you left off **(click)**
          - And if you loop all the way through an iterator and then **(click)** try to loop over it again... it'll be empty. **(click)**  This iterator is *exhausted*.
        </aside>
      </section>

      <section>
        <h3>Iterators are lazy</h3>
        <ul>
          <li class="fragment">They compute their next value as you loop over them</li>
          <li class="fragment">They might not store any values "inside" themselves at all</li>
        </ul>
        <aside class="notes" data-markdown>
          - So the benefit of iterators is that they are **lazy**...
          - Instead of doing a whole bunch of work upfront... **(click)**
          - ...they do little *bits* as we loop over them
          - They usually don't know what items they've given you already or what items might come next **(click)**: they only know how to give you their *next* item
          - Which means they're often pretty memory efficient
          - When we loop over a file, whether it's a 1MB file or a 1GB file, it'll store the same amount of memory either way
          - ...
          - So... because we consume items from iterators as we loop over them, you can think of iterators as like...
        </aside>
      </section>

      <section data-background-image="hello-kitty-pez.jpg">
        <aside class="notes" data-markdown>
          - Hello Kitty PEZ dispensers.
          - When you take a PEZ out, it's gone: you've **consumed** it
          - And once the dispenser is empty, it's useless: there's no way to reload it
          - And it has no memory of what used to be in it, or how many things might still be in it
          - Iterators are **lazy, single-use** iterables
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h2 class="fragment">How do you create iterators?</h2>
        <aside class="notes" data-markdown>
          - So **lazy looping** is all about:
            - creating iterators
            - and looping over iterators
          - We already how to loop over iterators...
          - So **(click)** how do we create iterators?
        </aside>
      </section>

      <section data-transition="slide-in fade-out">
        <pre class="python"><code data-trim data-noescape>
def denumerate(iterable):
    n = -1
    <span class="fragment bold-current" data-fragment-index=4>values = []</span>
    for item in iterable:
        <span class="fragment bold-current" data-fragment-index=4>values.append((n, item))</span>
        n -= 1
    <span class="fragment bold-current" data-fragment-index=5>return values</span>
        </code></pre>
        <pre class="python fragment" data-fragment-index=0><code data-trim data-noescape>
>>> colors = ['pink', 'green', 'purple', 'blue']
>>> <span class="fragment" data-fragment-index=1>for n, color in <span class="fragment bold-current" data-fragment-index=1>denumerate(colors)</span></span><span class="fragment" data-fragment-index=2>:
...     print(n, color)
...</span>
<span class="fragment" data-fragment-index=3>-1 pink
-2 green
-3 purple
-4 blue</span><span class="fragment" data-fragment-index=6></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - This function is very similar to the built-in `enumerate` function, except that it counts downward instead of up
          - So if we take an iterable, say a list of words **(click)** and pass it to this `denumerate` function **(click)**, and **(click)** loop over the result...
          - We'll get tuples with two things in them: **(click)**
            - numbers (counting downward)
            - and the actual items from that list
          - When we *call* this `denumerate` function it **(click)** builds up a list of all of the tuples it's going to give us and then **(click)** returns them to us all at once
          - ...which might not be very memory-efficient depending on *what* we're looping over and how big it is
          - ...
          - **(click)** Instead of creating all the tuples right away...
        </aside>
      </section>

      <section data-transition="slide-in fade-out">
        <pre class="python"><code data-trim data-noescape>
def denumerate(iterable):
    n = -1
    <span class="fragment fade-out" data-fragment-index=5>values = []</span>
    for item in iterable:
        <span class="fragment bold-current" data-fragment-index=6>values.append((n, item))</span>
        n -= 1
    <span class="fragment fade-out" data-fragment-index=4>return values</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - ...we can make this function return a **lazy iterator** to us...
          - ...one which only *makes* each tuple *just* before we need it
          - We can do this by actually *removing* code from this function
          - First we'll remove the `return` statement **(click)**
          - Then we'll remove the empty `values` list **(click)**
          - Then that `values.append` call **(click)** (which doesn't make any sense anymore)... it's going to turn into *a `yield` statement*
        </aside>
      </section>

      <section data-transition="fade-in fade-out">
        <pre class="python"><code data-trim data-noescape>
def denumerate(iterable):
    n = -1

    for item in iterable:
        yield (n, item)
        n -= 1<span>

</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - This thing we've just made...
        </aside>
      </section>

      <section data-transition="fade-in slide-out">
        <h3 class="fragment" data-fragment-index=0>Generator function</h3>
        <pre class="python"><code data-trim data-noescape>
def denumerate(iterable):
    n = -1
    for item in iterable:
        <span class="fragment bold-current" data-fragment-index=6>yield (n, item)</span>
        n -= 1
        </code></pre>
        <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
>>> colors = ['pink', 'green', 'purple', 'blue']
>>> items = denumerate(colors)
>>> <span class="fragment" data-fragment-index=2>next(items)
(-1, 'pink')
>>> </span><span class="fragment" data-fragment-index=3>list(e)
[(-2, 'green'), (-3, 'purple'), (-4, 'blue')]
>>> </span><span class="fragment" data-fragment-index=4>list(e)</span>
<span class="fragment" data-fragment-index=5>[]</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - ... is called a *generator function* **(click)**
          - Generator functions return iterators when you call them
          - So when we **(click)** call this `denumerate` function we've just made... we can take the thing we get back from it and
            - call `next` on it **(click)**
            - Or loop over it **(click)**
            - But if we loop over again **(click)**, it'll be empty **(click)**
            - Because we've *exhausted* this iterator
          - That **(click)** yield statement turned a **function** into a **generator function**
          - Generator functions are *really different* from normal functions
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index=1>def gimme_five():
    print('Start!')
    return 5
</span>
<span class="fragment" data-fragment-index=8>def denumerate(iterable):
    print('Start?')
    n = -1
    for item in iterable:
        <span class="fragment bold-current" data-fragment-index=13>yield (n, item)</span>
        n -= 1
</span>
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=3>x = gimme_five()</span>
<span class="fragment" data-fragment-index=4>Start!
>>> </span><span class="fragment" data-fragment-index=5>x
</span><span class="fragment" data-fragment-index=6>5
>>> </span><span class="fragment" data-fragment-index=9>y = denumerate(["purple", "blue", "pink"])</span><span class="fragment" data-fragment-index=10>
>>> </span><span class="fragment" data-fragment-index=11>y
</span><span class="fragment" data-fragment-index=12>&lt;generator object denumerate at 0x7febbdeaae58></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - If you have **(click)** a regular function in Python...
          - And you call it **(click)**
          - It'll execute that function **(click)**
          - And if we look at the thing it gave us back **(click)**
          - We'll see its return value **(click)**
          - But if you take a generator function **(click)**
          - And you call it... **(click)**
          - ... **(click)** ... Nothing happens. The function *doesn't* execute.
          - And if we look at what it gave us back... **(click)**
          - We'll see it gave us a generator object **(click)**
          - **Functions** and **generator functions** are *completely* different animals: all because of that `yield` statement **(click)**
          - Alright we're going to walk through every step of looping over a generator object.
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
def denumerate(iterable):
    <span class="fragment bold-current" data-fragment-index=1>print('start!')</span>
    n = -1
    <span class="fragment bold-current" data-fragment-index=10><span class="fragment bold-current" data-fragment-index=19>for item in iterable</span>:
        <span class="fragment bold-current" data-fragment-index=1>print('about to yield')</span></span>
        <span class="fragment bold-current" data-fragment-index=12><span class="fragment bold-current" data-fragment-index=3>yield (n, item)</span></span>
        <span class="fragment bold-current" data-fragment-index=17><span class="fragment bold-current" data-fragment-index=8>print('incrementing!')</span></span>
        n -= 1
    <span class="fragment bold-current" data-fragment-index=20>print('all done!')</span>
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=0>for <span class="fragment bold-current" data-fragment-index=4><span class="fragment bold-current" data-fragment-index=13>n, color</span></span> in <span class="fragment bold-current" data-fragment-index=16><span class="fragment bold-current" data-fragment-index=7>denumerate(["purple", "pink"])</span></span>:
...     <span class="fragment bold-current" data-fragment-index=14><span class="fragment bold-current" data-fragment-index=5>print(f"Color {n} is {color}")</span></span>
...</span>
<span class="fragment" data-fragment-index=2>start!
about to yield</span>
<span class="fragment" data-fragment-index=6>Color -1 is purple</span>
<span class="fragment" data-fragment-index=9>incrementing</span>
<span class="fragment" data-fragment-index=11>about to yield</span>
<span class="fragment" data-fragment-index=15>Color -2 is pink</span>
<span class="fragment" data-fragment-index=18>incrementing</span>
<span class="fragment" data-fragment-index=21>all done!</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - This is going to be quick so I'm going to be *bolding* the code we're on as we go...
          - When we loop over a generator object **(click)**
          - It's going to start executing our function
          - So we'll see **(click)** those first couple print calls **(click)**
          - And then the generator gets to **(click)** the `yield` statement, puts itself on pause, and yields control **(click)** back to our loop: passing that tuple back to us
          - Then we execute the **(click)** body of our loop which prints something out **(click)** and **(click)** we ask the generator for its next item... which starts it up where it left off: right after **(click)** the `yield`
          - So it prints **(click)**, and gets to **(click)** another iteration of its loop, prints again **(click)**, and yields again **(click)**
          - Which pauses it and passes us **(click)** another tuple
          - And we execute **(click)** the body of our loop, which **(click)** prints something out
          - And then we ask **(click)** for another item... which starts our generator where it left off **(click)**, which means it'll print again **(click)**
          - And then try to loop **(click)**, but see that there aren't more items to loop over, so it'll execute **(click)** the rest of the generator function **(click)**
          - And then it returns, which means it's now exhausted: there are **no more items** in this generator. So we're done looping.
          - ...
        </aside>
      </section>

      <section>
        <h4><strong>Generators <span class="fragment">(and iterators)</span> <span class="fragment">do work as you loop over them</span></strong></h4>
        <ul class="fragment">When asked for their next item:
          <li class="fragment">They do work to figure out that item</li>
          <li class="fragment">Yield that item to the loop they're in</li>
          <li class="fragment">And put themselves on pause until asked for another item</li>
        </ul>
        </p>
        <aside class="notes" data-markdown>
          - Generators...
          - And all iterators... **(click)**
          - Compute their items **(click)** as you loop over them
          - When you ask a generator for its next item... **(click)**
          - It'll execute code **(click)** to figure out what that item is
          - Then it'll yield that item **(click)** to whoever is looping over it
          - And put itself on pause **(click)**, until you ask it to generate another item for you
          - So lazy looping is all about *not doing any work* until **just before you need the next item**
        </aside>
      </section>

      <section>
        <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
>>> <span class="fragment bold-current" data-fragment-index=15>def square_all(numbers):
...     for n in numbers:
...         yield n**2</span>
...
>>> <span class="fragment" data-fragment-index=2>numbers = [2, 1, 3, 4, 7, 11]
>>> </span><span class="fragment" data-fragment-index=3>squares = square_all(numbers)
>>> </span><span class="fragment" data-fragment-index=4>squares</span>
<span class="fragment" data-fragment-index=5><span class="fragment bold-current" data-fragment-index=14>&lt;generator object square_all at 0x7f11191b78b8></span>
>>> </span><span class="fragment" data-fragment-index=6><span class="fragment bold-current" data-fragment-index=16><span class="fragment bold-current" data-fragment-index=13>squares = (n**2 for n in numbers)</span></span>
>>> </span><span class="fragment" data-fragment-index=7>squares_list = [n**2 for n in numbers]
>>> </span><span class="fragment" data-fragment-index=8>squares_list
</span><span class="fragment" data-fragment-index=9>[4, 1, 9, 16, 49, 121]
>>> </span><span class="fragment" data-fragment-index=10>squares</span><span class="fragment" data-fragment-index=11>
<span class="fragment bold-current" data-fragment-index=12>&lt;generator object &lt;genexpr> at 0x7f78f87af0c0></span></span><span class="fragment" data-fragment-index=16></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - Generator functions return generators to us and generators are iterators
          - *This* **(click)** is a generator function
          - It's yielding, just like our `denumerate` generator function did before
          - And **(click)** if we call this generator function... **(click)**
          - The thing we'll get back... **(click)**
          - Is a generator object **(click)**
          - But... this isn't the only way to make generator objects
          - *This* **(click)** is a generator expression
          - It *looks* like a list comprehension **(click)**
          - Except list comprehensions **(click)** make new lists **(click)**
          - But generator expressions **(click)** make new *generators* **(click)**
          - *This* generator object **(click)** from this generator expression **(click)** does the same thing as this generator object **(click)** from this generator function **(click)**
          - So instead of making a whole generator function, sometimes **(click)** you can just write a single expression
        </aside>
      </section>

      <section>
        <h3>How to make iterators</h3>
        <ol>
          <li class="fragment" data-fragment-index=1>Write a generator function <span class="fragment" data-fragment-index=3>(calling it returns an iterator)</span></li>
          <li class="fragment" data-fragment-index=2>Make a generator expression <span class="fragment" data-fragment-index=4>(which makes an iterator)</span></li>
          <li class="fragment" data-fragment-index=5><span class="fragment strike" data-fragment-index=6>Make an iterator class</span></li>
        </ol>
        <aside class="notes" data-markdown>
          - So to make an iterator..
          - You can either make a generator function... **(click)**
          - Or a generator expression **(click)**
          - Calling a generator function **(click)** makes a generator
          - And evaluating a generator expression **(click)** makes generator
          - And generators *are* iterators... the same way files are iterators
          - Technically **(click)** there is another way to make your own iterator... **(click)** but you don't need to know about it we're not going to talk about that
          - Now, once we've got an iterator...
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h2>How are iterators used?</h2>
        <aside class="notes" data-markdown>
          - ...what do we do with it?
          - ...
          - The obvious thing to do is...
        </aside>
      </section>

      <section>
        <h3>Looping over iterators</h3>
        <pre class="python fragment"><code data-trim data-noescape>
squares = (n**2 for n in range(1000))
<span class="fragment">total = 0
for n in squares:
    total += n</span>
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
total = sum((n**2 for n in range(1000)))
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
total = sum(n**2 for n in range(1000))
        </code></pre>
        <aside class="notes" data-markdown>
          - Loop over it.
          - We can take an iterator **(click)** of numbers, loop over it **(click)**, and sum up all the numbers
          - Or... we could pass that iterator to a function **(click)** that'll loop over it for us
          - This second way of doing things is **so common** that the Python core developers made a special rule with generator expressions:
            - if we pass a generator expression into a function as its only argument, we can **(click)** *drop* those extra parenthesis
            - ... kind of merging the function call and the generator expression syntax into one.
          - ...
          - Regardless of how we do it, **looping** is the **very last thing** we'll do with an iterator: because once we loop over iterators, they're exhausted
          - But *before* we loop, we could take our iterator and **wrap it** in *another iterator*
        </aside>
      </section>

      <section>
        <h3>Wrapping iterators in iterators</h3>
        <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
<span class="fragment" data-fragment-index=2>import csv
</span><span class="fragment" data-fragment-index=1>with open('expenses.csv') as expenses_file:</span><span class="fragment" data-fragment-index=3>
    <span class="fragment bold-current" data-fragment-index=5><span class="fragment bold-current" data-fragment-index=14>expense_rows</span></span> = <span class="fragment bold-current" data-fragment-index=5><span class="fragment bold-current" data-fragment-index=13>csv.reader</span></span>(<span class="fragment bold-current" data-fragment-index=4><span class="fragment bold-current" data-fragment-index=12>expenses_file</span></span>)</span>
    <span class="fragment" data-fragment-index=10>travel_costs = <span class="fragment bold-current" data-fragment-index=15>sum</span>(</span><span class="fragment bold-current" data-fragment-index=14><span class="fragment" data-fragment-index=6><span class="fragment fade-out" data-fragment-index=18>(</span>
        <span class="fragment" data-fragment-index=9>float(cost)</span>
        <span class="fragment" data-fragment-index=7>for date, merchant, cost, category in expense_rows</span>
        <span class="fragment" data-fragment-index=8>if category == 'travel'</span>
    <span class="fragment fade-out" data-fragment-index=18>)</span></span></span><span class="fragment" data-fragment-index=10>)</span><span class="fragment" data-fragment-index=16></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - As an example, we're going to write some code that adds up travel expenses.
          - We're going to read a CSV file of expenses **(click)**
          - ... using **(click)** the `csv` module to parse it **(click)**
          - So we have a file object **(click)** (which is an iterator) and we've passed it to `csv.reader` **(click)**, which returns **another iterator**...
          - We're going to take *that* iterator, and wrap **(click)** a generator expression around it
          - This generator will **(click)** unpack the columns from each row, grab only **(click)** the travel expenses, and convert their costs **(click)** to floating point numbers
          - And then we'll take that whole generator expression, and pass it to **(click)** the `sum` function
          - So we have an iterator **(click)**, wrapped in another iterator **(click)**, wrapped in another iterator... **(click)**
          - And no looping happens until the `sum` function **(click)** starts looping over that outermost iterator: that generator expression that we pass to it **(click)**
          - And again, because we're passing a generator expression straight into another function, we can **(click)** drop that extra set of parentheses
          - So...
        </aside>
      </section>

      <section data-background-image="hello-kitty-pez.jpg">
        <aside class="notes" data-markdown>
          - While iterators *are* like Hello Kitty PEZ dispensers, that analogy doesn't really reflect the fact that iterators can be *wrapped* in other iterators
          - You can sort of think of iterators as like...
        </aside>
      </section>

      <section>
        <img src="xenomorph.gif" class="no-style">
        <aside class="notes" data-markdown>
          - Xenomorphs: where there's one head that's wrapped around another one
          - ... except that... you can wrap iterators as many levels deep as you want: heads inside heads inside of heads
          - ...and also... that PEZ analogy still holds...
          - So maybe... iterators are really like...
          - Recursive Hello Kitty PEZ dispenser xenomorphs...
        </aside>
      </section>

      <section data-background-image="xenokitty.jpg">
        <aside class="notes" data-markdown>
          - When you loop over iterators wrapped around iterators:
            - the outer one has to *delegate* to the inner one, repeatedly, until you get to the inner most one...
            - and then you have to work back up to get the item you're actually looking for
          - ...
          - If this analogy doesn't work for you, I'm sorry, but you're going to have to come up with your own.
        </aside>
      </section>

      <section>
        <h2>What do you do with iterators?</h2>
        <ol>
          <li class="fragment" data-fragment-index=1><span class="fragment bold-current" data-fragment-index=4>Wrap another iterator around them</span> <span class="fragment" data-fragment-index=5>by
              <ul>
                <li>passing them to a generator function</li>
                <li class="fragment" data-fragment-index=6>creating a generator expression</li>
                <li class="fragment" data-fragment-index=7>calling another iterator-returning function</li>
              </ul>
          </li>
          <li class="fragment" data-fragment-index=2><span class="fragment bold-current" data-fragment-index=8>Loop over them<span class="fragment" data-fragment-index=3>, but only once</span></span>
            <ul>
              <li class="fragment" data-fragment-index=9>writing a <code>for</code> loop <span class="fragment" data-fragment-index=10>or a list comprehension</span></li>
              <li class="fragment" data-fragment-index=11>calling another function that will do the looping</li>
            </ul>
          </li>
        </ol>
        <aside class="notes" data-markdown>
          - So there are two general things you can *do* with an iterator...
          - You can **(click)** wrap it in another iterator, as many times as you like
          - But you'll always eventually **(click)** loop over that outermost iterator
          - ... But only once. **(click)** Because it'll be exhausted after you've looped.
          - There are 3 ways to wrap around an iterator... **(click)**
          - Pass it to a generator function **(click)**
          - Write a generator expression **(click)**
          - Or pass it to **(click)** some other function that'll give us back another iterator (like `csv.reader` did)
          - There are also a couple ways to loop over iterator... **(click)**
          - You can write a `for` loop **(click)**
          - ...Or a list comprehension **(click)**
          - Or... call some function that'll do the looping for you... **(click)** (like the `sum` function)
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h2 class="fragment">The Problem: Revisited</h2>
        <h3 class="fragment">Find logged errors (with context)</h3>
        <aside class="notes" data-markdown>
          - Let's finally revisit the **(click)** problem code we saw earlier
          - So we were trying to find errors in a log file **(click)** but we also wanted to print out the line just before the error and the line just after it
        </aside>
      </section>

      <section data-transition="slide-in fade-out">
        <pre class="python"><code data-trim data-noescape>
with open('logs.txt') as log_file:
    <span class="fragment bold-current" data-fragment-index=2>prev = line = None</span>
    for next in log_file:
        next = next.rstrip('\n')
        if line and 'error' in line.lower():
            print(prev, line, next, sep='\n')
        <span class="fragment bold-current" data-fragment-index=2>prev, line = line, next</span>
    <span class="fragment bold-current" data-fragment-index=2>if line and 'error' in line.lower():
        print(prev, line, None, sep='\n')</span><span class="fragment" data-fragment-index=3></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - This is what we started with
          - A lot of the logic here is around **(click)** getting the line just *before* and the line just *after* the current line
          - So **(click)** we could refactor our code like this...
        </aside>
      </section>

      <section data-transition="fade-in fade-out">
        <h3 style="visibility: hidden;">Find logged errors (with context)</h3>
        <pre class="python" data-fragment-index=3><code data-trim data-noescape>
with open('logs.txt') as log_file:
    for prev, line, next in <span class="fragment bold-current" data-fragment-index=3>around</span>(<span class="fragment bold-current" data-fragment-index=2>strip_newlines</span>(<span class="fragment bold-current" data-fragment-index=1>log_file</span>)):
        if 'error' in line.lower():
            print(prev, line, next, sep='\n')<span class="fragment" data-fragment-index=4></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - And we're done... except not really.
          - ...Because we're passing our `log_file` **(click)** to two functions that don't actually exist:
            - one that **(click)** lazily strips newlines from the ends of each line
            - and one that **(click)** gives us the line before and after our current line
          - but if **(click)** these functions existed and they gave us lazy iterables, our code would be just an efficient and a lot easier to read
          - So if we could figure out how to write these functions, our code could be a lot more readable.
        </aside>
      </section>

      <section data-transition="fade-in fade-out">
        <pre class="python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index=2>def around(iterable):
    """Yield (prev, item, next) for each item in iterable."""
    before = current = None
    for after in iterable:
        if current is not None:
            yield (before, current, after)
        before, current = current, after
    if current is not None:
        yield (before, current, None)</span>

<span class="fragment" data-fragment-index=1>def strip_newlines(lines):
    for line in lines:
        yield line.rstrip('\n')</span>

<span class="fragment bold-current" data-fragment-index=3>with open('logs.txt') as log_file:
    for prev, line, next in around(strip_newlines(log_file)):
        if 'error' in line.lower():
            print(prev, line, next, sep='\n')</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - Fortunately you don't have to figure out how to write these functions because I already did that...
          - **(click)** This is `strip_newlines`
          - And **(click)** this is `around`
          - This code is a lot longer than what we started with... but I find it **more readable**, mostly because...
          - **(click)** this four line loop *hides* details that we don't care about
          - We've broken our loop up into little bits of work so that a *reader* of our code can understand what's going on without needing to worry about the exact *details* of every step
          - Now...
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h2 class="fragment">Code you don't need to write</h2>
        <aside class="notes" data-markdown>
          - I do want to make an important note...
          - While you're *writing* generator functions, keep in mind that the best code, **(click)** is code you don't even need to write
          - Python has with a bunch of iterator-returning functions built-in
        </aside>
      </section>

      <section>
        <h3>Pre-written lazy looping  helpers</h3>
        <ul>
          <li class="fragment"><code>enumerate</code></li>
          <li class="fragment"><code>zip</code></li>
          <li class="fragment"><code>reversed</code></li>
          <li class="fragment"><code>any</code> and <code>all</code></li>
          <li class="fragment">Everything in the <code>itertools</code> module</li>
          <li class="fragment">Third-party libraries: more-itertools and boltons</li>
        </ul>
        <aside class="notes" data-markdown>
          - There's `enumerate` **(click)**
          - `zip`  **(click)**
          - `reversed`  **(click)**
          - `any` and `all` **(click)**
          - And **(click)** a whole module in the standard library that's *all about* iterators and lazy looping
          - And if you don't find what you're looking for included with Python, **(click)** it might be hiding in a third-party library
          - There's no need to reinvent the wheel if a good one already exists
          - For example...
        </aside>
      </section>

      <section data-transition="fade-in fade-out">
        <pre class="python"><code data-trim data-noescape>
def around(iterable):
    """Yield (prev, item, next) for each item in iterable."""
    before = current = None
    for after in iterable:
        if current is not None:
            yield (before, current, after)
        before, current = current, after
    if current is not None:
        yield (before, current, None)</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - This `around` generator function we wrote before...
          - We could have written like this...
        </aside>
      </section>

      <section data-transition="fade-in fade-out">
        <pre class="python" data-fragment-index=3><code data-trim data-noescape>
from itertools import chain
from more_itertools import windowed


def around(iterable):
    """Yield (prev, item, next) for each item in iterable."""
    return windowed(chain([''], iterable, ['']), size=3)
        </code></pre>
        <aside class="notes" data-markdown>
          - If we'd used either boltons or more-itertools
          - Instead of reinventing someone else's iterator... we can just wrap around it
          - ...
          - So...
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h2>Words are hard</h2>
        <aside class="notes" data-markdown>
          - **22:00**
          - ...I have some bad news
          - The way I used the word "generator" in this talk isn't universal
          - Here's the way I defined these terms...
        </aside>
      </section>

      <section data-transition="fade-in slide-out">
        <ul>
          <li class="fragment" data-fragment-index=0><strong class="fragment underline-current" data-fragment-index=8>Iterator</strong>: lazy single-use iterable</li>
          <li class="fragment" data-fragment-index=1><strong class="fragment underline-current" data-fragment-index=5>Generator function</strong>: a syntax for easily creating iterators</li>
          <li class="fragment" data-fragment-index=2><strong class="fragment underline-current" data-fragment-index=6>Generator expression</strong>: comprehension which returns a generator instead of a list</li>
          <li class="fragment" data-fragment-index=3><strong class="fragment underline-current" data-fragment-index=7>Generator object</strong> (aka <span class="fragment underline-current" data-fragment-index=4>generator</span>): an iterator created from a generator function (or a generator expression)</li>
          <span class="fragment" data-fragment-index=9></span>
        </ul>
        <aside class="notes" data-markdown>
          - An **iterator** is a **(click)** lazy single-use iterable that computes its *next* item and give it back to you as you loop over it
          - **(click)** A **generator function** is a special syntax that we can use for making a function which returns an iterator
          - **(click)** A **generator expression** is a special syntax, that looks like a list comprehension, and when you make one of these expressions you'll get an iterator back
          - The type of iterator you get back from each of these is called **(click)** a **generator object** or just *a generator*. **(click)**
          - When you call a generator function **(click)** or evaluate a generator expression **(click)**, you *get* one of these generator objects **(click)**
          - And generator objects are a type **(click)** of **iterator**... they're basically the *easiest way* to make an iterator **(click)**
          - So that's how *I* define these terms...
          - But the Python documentation disagrees with me...
        </aside>
      </section>

      <section data-background="#ffffff" data-transition="slide-in none-out">
        <table class="no-style no-padding top-aligned">
          <tbody>
            <tr>
              <td class="fragment" data-fragment-index=1><small><nobr><strong>generator function</strong></nobr></small></td>
              <td class="fragment" data-fragment-index=2><img src="generator-term.png" class="no-style"></td>
            </tr>
            <tr>
              <td class="fragment" data-fragment-index=3>
                <small><strong><nobr>generator object</nobr></small></strong>
                <small class="fragment" data-fragment-index=4><strong><nobr>generator</nobr></small></strong>
              </td>
              <td class="fragment" data-fragment-index=5><img src="generator-iterator-term.png" class="no-style"></td>
            </tr>
            <tr>
              <td class="fragment" data-fragment-index=6><small><strong><nobr>generator expression</nobr><br><nobr class="fragment" data-fragment-index=9>generator comprehension</nobr></strong></small></td>
              <td class="fragment" data-fragment-index=8><img src="generator-expression-term.png" class="no-style"></td>
            </tr>
            <tr class="fragment" data-fragment-index=10>
              <td colspan=2><small>"Calling a generator function returns a generator" - Luciano Ramalho in Fluent Python (page 429)</small></td>
            </tr>
          </tbody>
        </table>
        <aside class="notes" data-markdown>
          - What I call a *generator function* **(click)**, it calls a *generator* **(click)**
          - And what I call a *generator object* **(click)** or just a *generator* **(click)**, it calls a *generator iterator* **(click)**... which isn't a term I've ever heard anyone *use* outside of the Python documentation
          - Fortunately generator expression **(click)** is unambiguous **(click)**, even though I do sometimes wish they were called generator comprehensions **(click)**
          - So you might think: Trey thinks one thing and the Python documentation says something else, so obviously Trey is wrong.
          - And I might agree with you, except that I'm not alone in the way I use these terms
          - Many other Python educators **(click)** use the term "generator" the same way I do
          - Lots of people use the term "generator" to refer to a generator object and "generator function" to refer to the function itself
          - In fact...
        </aside>
      </section>

      <section data-background="#ffffff" data-transition="none-in slide-out">
        <table class="no-style no-padding top-aligned">
          <tbody>
            <tr>
              <td><small><nobr><strong>generator function</strong></nobr></small></td>
              <td><img src="generator-term-highlighted.png" class="no-style"></td>
            </tr>
            <tr>
              <td>
                <small><strong><nobr>generator object</nobr></small></strong>
                <small><strong><nobr>generator</nobr></small></strong>
              </td>
              <td><img src="generator-iterator-term.png" class="no-style"></td>
            </tr>
            <tr>
              <td><small><strong><nobr>generator expression</nobr><br><nobr>generator comprehension</nobr></strong></small></td>
              <td><img src="generator-expression-term.png" class="no-style"></td>
            </tr>
            <tr>
              <td colspan=2><small>"Calling a generator function returns a generator" - Luciano Ramalho in Fluent Python (page 429)</small></td>
            </tr>
          </tbody>
        </table>
        <aside class="notes" data-markdown>
          - ...the Python documentation says the term generator "may be used to refer to a generator iterator in some contexts"
          - ...
          - So these terms are confusing, different people use them differently in different contexts, and that's just the way life is in generator land
          - ...
          - To recap...
        </aside>
      </section>

      </section>

      <section>
        <ul>
          <li class="fragment">Iterators are lazy single-use iterables</li>
          <li class="fragment">Generators are the "easy" way to make an iterator</li>
          <li class="fragment">There are lots of lazy looping helpers included with Python and in third-party libraries</li>
          <li class="fragment">Iterators help make more more memory-efficient code</li>
          <li class="fragment">Wrapping iterators-in-iterators can break up big and scary loops into small understandable steps</li>
        </ul>
        <aside class="notes" data-markdown>
          - Iterators lazily compute their next item as you loop over them **(click)**
          - The easiest way to make your own iterator is to make a generator **(click)**
          - Though you often don't even need to make your iterator because **(click)** Python comes bundled with lots of lazy looping tools built-in
          -  The purpose of iterators is to make your code **(click)** more memory efficient... even if you're looping over a really *big* iterable
          - And wrapping iterators in iterators **(click)** can help you break your looping work up into little chunks with descriptive names, which can really improve the readability of your code
          - If you're interested in diving into this topic more deeply...
        </aside>
      </section>

      <section data-background-image="lazy-looping-tutorial.png" class="no-controls">
        <div class="fragment" style="background: rgba(238, 238, 238, 0.9); ">
        <h1>Lazy Looping in Python</h1>
        <h3>Making and Using Generators and Iterators</h3>
        </div>
        <aside class="notes" data-markdown>
          - I gave **(click)** a tutorial on this at PyCon which you can find along with a bunch of other useful resources...
        </aside>
      </section>

        <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
          <h2 style="margin-top: 1.5em;">Recommended resources at</h2>
          <h2><a href="http://trey.io/lazy-looping">trey.io/lazy-looping</a></h2>
          <div style="margin-top: 2em;">
            <p style="float: left; margin-right: 2em;">
              <strong>Trey Hunner</strong><br>
              <small>Python Team Trainer</small>
            </p>
            <p style="float: left;">
            <a href="http://truthful.technology"><img src="logo.svg" class="no-style logo"></a>
            <a href="http://pythonmorsels.com"><img src="python-morsels-logo.svg" class="no-style logo"></a>
            </p>
            <p style="clear: all;"></p>
          </div>
          <div style="clear: all;"></div>
          <div style=" float: left; margin-top: 0.5em;">
            <p style="float: left; margin-right: 2em;"><small>
              <a href="https://www.flickr.com/photos/30223382@N06/4151828376">Hello Kitty PEZ image &copy; Deborah Austin</a><br>
            </small></p>
            <p style="float: left; margin-right: 2em;"><small>
              <a href="https://giphy.com/gifs/alien-xenomorph-covenant-l0Iy1DPCfobWsxOco">Xenomorph GIF &copy; Truck Torrence</a><br>
            </small></p>
          </div>
          <aside class="notes" data-markdown>
            - ...at that URL there.
            - Thank you!
          </aside>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/truthful.js"></script>


    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
