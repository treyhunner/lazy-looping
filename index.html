<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Lazy Looping</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Lazy Looping</h1>
          <h2>The Next Iteration</h2>
          <p>
          <small><a href="https://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            TODO
          </aside>
        </section>

        <section>
          <div class="aboutme-card">
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos" alt="Truthful Technology"></a>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonmorsels.com"><img src="morsels-logo.svg" class="no-style aboutme-logos" alt="Python Morsels"></a>
          </div>
          <aside class="notes" data-markdown>
            - My name is Trey
            - I help Python &amp; Django teams on-board new teammates and turn their front-end developers into full-stack Django developers.
            - And I run a Python exercise subscription service where where I send out 1 Python exercise every week.  It's called Python Morsels.
            - TODO
          </aside>
        </section>

      </section>

      <section>

      <section>
        <h2 class="fragment">Problem 1</h2>
        <h3 class="fragment">Find first 10 errors from yesterday</h3>
        <aside class="notes" data-markdown>
          - I'd like to start by *very briefly* looking at two blocks of code that are difficult to read
          - I don't expect to remember or really even understand these blocks of code right now, but these are going to be our starting point
          - So problem 1...
          - We have some code that again looks for errors in a log file, but only the ones that happened yesterday and only the first 10 lines
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
from datetime import date, timedelta

yesterday = date.today() - timedelta(1)

with open('log.txt') as log_file:
    i = 0
    for line in log_file:
        if str(yesterday) in line and 'error' in line.lower():
            i += 1
            if i &lt;= 10:
                print(line, end='')
            else:
                print('[...]')
                break
        </code></pre>
        <aside class="notes" data-markdown>
          - This is our code
          - We're looping over lines in our log file, checking for yesterday's date in them, and then we have a lot of logic around getting just the first 10
          - If there were more than errors yesterday, we print out an ellipsis to signify that there's more but that we stopped after 10
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h2 class="fragment">Problem 2</h2>
        <h3 class="fragment">Find logged errors (with context)</h3>
        <aside class="notes" data-markdown>
          - Problem 2...
          - We have some code that finds lines in a log file that contain errors and then we print out the line itself and the two lines around it
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
with open('logs.txt') as log_file:
    prev = line = None
    for next in log_file:
        next = next.rstrip('\n')
        if line and 'error' in line.lower():
            print(prev, line, next, sep='\n')
        prev, line = line, next
    if line and 'error' in line.lower():
        print(prev, line, None, sep='\n')
        </code></pre>
        <aside class="notes" data-markdown>
          - This is our code
          - We're looping over lines in a log file, checking for errors, and then there's a lot of logic around keeping track of the previous line and the next line as we loop
          - We're going to look at this later
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h2 class="fragment current-visible" data-fragment-index=1>Lazy Looping</h2>
        <h3><span class="fragment" data-fragment-index=4>What are </span><span class="fragment" data-fragment-index=2>iterables</span><span class="fragment" data-fragment-index=3> and iterators</span><span class="fragment" data-fragment-index=4>?</span></h3>
        <aside class="notes" data-markdown>
          - You can completely forget about those for now...
          - We're going to come back to those two problems at the end of this talk and refactor those code blocks, by using lazy looping
          - Lazy Looping is all about iterables and iterators
          - So the first thing we need to do is define what iterables and iterators are...
        </aside>
      </section>

      <section>
        <h3>Iterable</h3>
        <p class="fragment">An iterable is anything you can loop over.</p>
        <pre class="python fragment"><code data-trim data-noescape>
for thing in <span class="fragment bold-current">my_iterable</span>:
    do_something_with(thing)
        </code></pre>
        <aside class="notes" data-markdown>
          - An iterable is **(click)** anything that you can loop over
          - lists, strings, tuples, dictionaries, files, and lots of other things things in Python are iterables
          - If you can write a `for` loop to iterate over some object it is, by definition, an iterable
          - We're mostly already intuitively familiar with iterables... but what are iterators?
        </aside>
      </section>

      <section>
        <h3>Iter<span class="fragment bold-current" data-fragment-index=1>ator</span></h3>
        <span class="fragment" data-fragment-index=2></span>
        <p class="fragment" data-fragment-index=3><span class="fragment strike" data-fragment-index=6>The thing that powers iterables</span></p>
        <p class="fragment" data-fragment-index=4><span class="fragment bold-current" data-fragment-index=7>A special kind of "lazy" iterable</span></p>
        <aside class="notes" data-markdown>
          - An iter-*ator* is a bit more complicated than an iter-*able*
          - ...
          - There are two definitons of iterators:
            1. First: Iterators are the objects that powers all iteration in Python: you can get an iterator from any iterable in order to loop over one item at a time
            2. Second: you can think of iterators as a special kind of *lazy* iterable which is *consumed* as you loop over
          - We're going to ignore that first definition.  It doesn't really matter to us right now.
          - We're going to focus mostly on that *second* definition.
          - If you *are* interested in that first definition...
        </aside>
      </section>

      <section data-background="#ffffff">
        <div class="fragment">
        <h1>Loop Better</h1>
        <h4>a deeper look at iteration in Python</h4>
        <p>
        <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
        </p>
        </div>
        <aside class="notes" data-markdown>
          - ... you can watch another talk of mine, called Loop Better
          - In it I talk about how `for` loops work under the hood in Python and a bunch of other stuff that's outside the scope of this talk today...
        </aside>
      </section>

      <section>
        <h3 class="fragment" data-fragment-index=2>Files are iterators</h3>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>my_file = open("my_file.txt")
>>> </span><span class="fragment" data-fragment-index=3>next(my_file)
'This is line 1 of the file'
>>> </span><span class="fragment" data-fragment-index=4>next(my_file)
<span class="fragment bold-current" data-fragment-index=8>'This is line 2 of the file'</span>
>>> </span><span class="fragment" data-fragment-index=5>for line in my_file:
...     print(line, end="")
...
</span><span class="fragment" data-fragment-index=6><span class="fragment bold-current" data-fragment-index=7>This is line 3 of the file</span>
This is line 4 (the end of the file)
>>> </span><span class="fragment" data-fragment-index=9>list(my_file)</span><span class="fragment" data-fragment-index=10>
[]</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - So we know what iterables are and we can think of examples of them...
          - But what's an example of an iterator?  Where do we see these things in Python?
          - One example of an iterable is a file.
          - In Python, **file objects are iterators**: files are *lazy iterables*...
          - By lazy I mean they're able to do work in order to generate items as you loop over them
          - We can do two things with an iterators:
            - We can pass them to Python's built-in `next` function, which gives us the *next* in them
            - ... with files that gives us the next line in the file
            - The other, more common thing, we can do with any iterator is loop over it: just like an other iterable in Python
          - But iterators are **lazy iterables**, which means they *consume* items as you loop over them
          - So if you start getting items from them, either by calling `next` or by looping, and then you **stop**... the next time you *start* again, you'll be right where you left off
          - And if you loop all the way through an iterator and then try to loop over it again... **it'll be empty**
          - We sometimes say that an iterator that doesn't have any more items in it is **exhausted**: which means its job is done and it doesn't have any use anymore
          - Iterators only go in **one direction**: forwards: they have no *memory* of what came before
        </aside>
      </section>

      <section>
        <h3>The benefits of iterators</h3>
        <aside class="notes" data-markdown>
          - TODO why care about iterators?  Well in the case of files... when you loop over a 1GB log file... you'll read each line of that file one at a time... technically Python maintains a small buffer of lines, but from our perspective we're getting one line at a time... when we read lines from our 1GB file, we're certainly not going to expect our system memory to spike by 1GB suddenly... Python never actually stores the whole file in memory: it reads from it lazily... and it's able to do this because it's behaving like an lazy iterable: an iterator
        </aside>
      </section>

      <section>
        <h3>The rules of iterators</h3>
        <ol>
          <li class="fragment">Looping over an iterator "consumes" items from it</li>
          <li class="fragment">The <code>next</code> function consumes just one item</li>
        </ol>
        <aside class="notes" data-markdown>
          - There are two **rules** that indicate whether something is an iterator
            1. When you loop over an iterator, you'll **consume** items from it
            2. And if you pass it to the  `next` function, you'll consume just *one* from it
          - Any iterable which is consumed as you loop over it is *almost certainly* an iterator and anything you can pass to the `next` function is *definitely* an iterator
          - ...
          - Because we consume items from iterators as we loop over them, you can think of iterators as like...
        </aside>
      </section>

      <section data-background-image="hello-kitty-pez.jpg">
        <aside class="notes" data-markdown>
          - Hello Kitty PEZ dispensers.
          - When you take a PEZ out, it's gone: you've **consumed** it
          - And once the dispenser is empty, it's useless: there's no way to reload it
          - Iterators are **lazy, single-use** iterables
        </aside>
      </section>

      <section data-transition="slide-in fade-out">
        <h3>Lazy Looping</h3>
        <ul>
          <li class="fragment">looping over an iterator</li>
          <li class="fragment">creating an iterator</li>
        </ul>
        <aside class="notes" data-markdown>
          - So we haven't really talked about this phrase: lazy looping... or what "laziness" means
          - So when I the phrase "lazy looping" I'm either referring to:
            - Looping over an iterator, which is a lazy iterable
            - Or creating our own iterator, which can be looped over later
          - Lazy looping is all about iterators
          - ...
          - We already *know* how to loop over an iterator: we write a `for` loop, just like any other time we're looping
          - So...
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h2>How do you create iterators?</h2>
        <aside class="notes" data-markdown>
          - How do we create iterators?
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">e = enumerate(['one', 'two', 'three', 'four'])
>>> </span><span class="fragment">e</span>
<span class="fragment">&lt;enumerate object at 0x7fe8b3a55c18>
>>> </span><span class="fragment">next(e)
(0, 'one')
>>> </span><span class="fragment">for thing in e:
...     print(e)
...</span>
<span class="fragment">(1, 'two')</span>
<span class="fragment">(2, 'three')</span>
<span class="fragment">(3, 'four')
>>> </span><span class="fragment">for thing in e:
...     print(e)
...</span><span class="fragment">
>>></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - We know that file objects in Python are iterators...
          - Another place we get an iterator from is Python's `enumerate` function
          - When we call `enumerate` we get back an `enumerate` object... and this object is an iterator
          - So just like other iterators, we can call `next` on it, or as we'd usually do with `enumerate` ... we can loop over it
          - And *as we loop over it*, it's *creating* two-item tuples that we're *consuming* from it
          - So if we loop over it a second time... it'll be empty
          - Because we've already consumed everything in this iterator
          - ...
          - Let's try to recreate this `enumerate` function...
        </aside>
      </section>

      <section data-transition="slide-in fade-out">
        <pre class="python"><code data-trim data-noescape>
def enumerate(iterable, start=0):
    n = start
    <span class="fragment bold-current" data-fragment-index=1><span class="fragment fade-out" data-fragment-index=5>values = []</span></span>
    for item in iterable:
        <span class="fragment bold-current" data-fragment-index=1><span class="fragment bold-current" data-fragment-index=6>values.append((n, item))</span></span>
        n += 1
    <span class="fragment bold-current" data-fragment-index=2><span class="fragment fade-out" data-fragment-index=4>return values</span></span><span class="fragment" data-fragment-index=3></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - This function is very similar to the built-in `enumerate` function... except there's one big difference: it's not lazy... by that I mean that it doesn't return an iterator
          - Instead of computing items as we loop over it, it just builds up a whole list of tuples right when we call it...
          - And then returns them to us
          - We can make this function into an iterator though...
          - And we can do it by actually *removing* code from it
          - First we'll remove the `return` statement
          - Then we'll remove the empty `values` list
          - Then that `values.append` call (which doesn't make any sense anymore)... it's going to turn into **a `yield` statement**
        </aside>
      </section>

      <section data-transition="fade-in fade-out">
        <pre class="python"><code data-trim data-noescape>
def enumerate(iterable, start=0):
    n = start

    for item in iterable:
        yield (n, item)
        n += 1<span>

</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - This thing we've just made...
        </aside>
      </section>

      <section data-transition="fade-in slide-out">
        <h3 class="fragment" data-fragment-index=0>Generator function</h3>
        <pre class="python"><code data-trim data-noescape>
def enumerate(iterable, start=0):
    n = start
    for item in iterable:
        <span class="fragment bold-current" data-fragment-index=6>yield (n, item)</span>
        n += 1
        </code></pre>
        <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
>>> e = enumerate(['one', 'two', 'three', 'four'])
>>> <span class="fragment" data-fragment-index=2>next(e)
(0, 'one')
>>> </span><span class="fragment" data-fragment-index=3>list(e)
[(1, 'two'), (2, 'three'), (3, 'four')]
>>> </span><span class="fragment" data-fragment-index=4>list(e)</span>
<span class="fragment" data-fragment-index=5>[]</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - ... is called a **generator function**
          - Generator functions return iterators when you call them
          - So when we call this `enumerate` function we've just made... we can take the thing we get back from it and
            - call `next` on it
            - And we can loop over it
            - And if we loop over twice, it'll be empty the second time
            - Because our generator function returned **an iterator** to us: just the like the built-in `enumerate` does
          - That `yield` statement turned what was a **regular function** into a **generator function**
          - And generator functions are pretty different from normal functions
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index=1>def gimme_five():
    print('Start!')
    return 5
</span>
<span class="fragment" data-fragment-index=8>def enumerate(iterable, start=0):
    print('Start?')
    n = 1
    for item in iterable:
        <span class="fragment bold-current" data-fragment-index=13>yield (n, item)</span>
        n += 1
</span>
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=3>x = gimme_five()</span>
<span class="fragment" data-fragment-index=4>Start!
>>> </span><span class="fragment" data-fragment-index=5>x
</span><span class="fragment" data-fragment-index=6>5
>>> </span><span class="fragment" data-fragment-index=9>y = enumerate(["purple", "blue", "pink"])</span><span class="fragment" data-fragment-index=10>
>>> </span><span class="fragment" data-fragment-index=11>y
</span><span class="fragment" data-fragment-index=12>&lt;generator object enumerate at 0x7febbdeaae58></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - If you have a regular function in Python...
          - And you call it
          - It'll execute that function
          - And if we look at the thing it gave us back
          - We'll see its return value
          - But if you take a generator function
          - And you call it...
          - Nothing happens
          - And if we look at what it gave us back...
          - We'll see it gave us a generator object
          - **Functions** and **generator functions** are *completely* different animals: all because of that `yield` statement
          - When we call a function, we gets return value
          - When we call a generator function we get a generator object.
          - And generator objects are iterators, the same way *file* objects are iterators
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
def enumerate(iterable, start=0):
    <span class="fragment bold-current" data-fragment-index=1>print('start!')</span>
    n = start
    <span class="fragment bold-current" data-fragment-index=10><span class="fragment bold-current" data-fragment-index=19>for item in iterable</span>:
        <span class="fragment bold-current" data-fragment-index=1>print('about to yield')</span></span>
        <span class="fragment bold-current" data-fragment-index=12><span class="fragment bold-current" data-fragment-index=3>yield (n, item)</span></span>
        <span class="fragment bold-current" data-fragment-index=17><span class="fragment bold-current" data-fragment-index=8>print('incrementing!')</span></span>
        n += 1
    <span class="fragment bold-current" data-fragment-index=20>print('all done!')</span>
        </code></pre>
        <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=0>for <span class="fragment bold-current" data-fragment-index=4><span class="fragment bold-current" data-fragment-index=13>n, color</span></span> in <span class="fragment bold-current" data-fragment-index=16><span class="fragment bold-current" data-fragment-index=7>enumerate(["purple", "pink"])</span></span>:
...     <span class="fragment bold-current" data-fragment-index=14><span class="fragment bold-current" data-fragment-index=5>print(f"Color {n} is {color}")</span></span>
...</span>
<span class="fragment" data-fragment-index=2>start!
about to yield</span>
<span class="fragment" data-fragment-index=6>Color 0 is purple</span>
<span class="fragment" data-fragment-index=9>incrementing</span>
<span class="fragment" data-fragment-index=11>about to yield</span>
<span class="fragment" data-fragment-index=15>Color 1 is pink</span>
<span class="fragment" data-fragment-index=18>incrementing</span>
<span class="fragment" data-fragment-index=21>all done!</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - To explain how generator functions *work* we're going to loop over a generator object and walk through every step of what our code does along the way...
          - This is going to be quick so if you've been asleep up to this point, maybe wake up for a minute or so
          - When we loop over the generator object we get back from our custom `enumerate` generator function...
          - It's going to start executing our function
          - So we'll see those first couple print calls happen
          - And then Python gets to the `yield` statement and it puts the generator on pause and yields control back to our loop: passing that back to us
          - We then executing the body of our loop which prints something out
          - And then we ask the generator for its next item
          - ...which means it's going to start up again where it left off, right after that last `yield`
          - So it prints, and then it gets to another iteration of its loop, prints again, and then yields again
          - Which puts it on pause, and passes another item back to us...
          - And we execute the body of our loop, which prints something out
          - And then we ask for another item again... which starts our generator executing where it left off, which means it'll print again
          - And then try to loop, but see that there aren't more items to loop over, so it'll execute the rest of the generator function
          - And then when it returns, it'll be exhausted: there are no more items in this generator. So we're done looping.
          - ...
          - TODO generator functions are different from regular functions... regular functions can control what they return to you, whereas a generator function always returns a generator to you... but that generator is an iterator: a lazy iterable, and yield statements are the thing that control the laziness: the passing of a message back to the code that's looping over it
          - TODO unlike regular functions, generator functions are a very special purpose tool: they're specifically for making a function which returns a lazy iterable, an iterator, that can do work and then put itself on pause to give you its next item
        </aside>
      </section>

      <section>
        TODO
        <aside class="notes" data-markdown>
          - TODO drive home the point: passing a 10GB log file to a generator function doesn't result in all the lines in that file being stored in memory... as we loop over the generator, it'll loop over lines our log file
          - TODO perfect place to use a generator is when you want to take some... (figure out the tweetable statement here)
          - TODO show trivial example (not <p> thing... that's too much) and show how we can make a generator function to move some of the logic out of it
        </aside>
      </section>

      <section>
        <pre class="python fragment"><code data-trim data-noescape>
def square_all(numbers):
    for n in numbers:
        yield n**2
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
>>> numbers = [2, 1, 3, 4, 7, 11]
>>> <span class="fragment">squares = square_all(numbers)
>>> </span><span class="fragment">squares</span>
<span class="fragment">&lt;generator object square_all at 0x7f11191b78b8>
>>> </span><span class="fragment">squares = (n**2 for n in numbers)
>>> </span><span class="fragment">squares_list = [n**2 for n in numbers]
>>> </span><span class="fragment">squares_list
</span><span class="fragment">[4, 1, 9, 16, 49, 121]
>>> </span><span class="fragment">squares</span><span class="fragment">
&lt;generator object &lt;genexpr> at 0x7f78f87af0c0></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - TODO
          - This is a generator expression.  It looks like a list comprehension, but it doesn't return a list to us: it returns a generator.
          - This... is equivalent ... **(click)** to this
          - Generator expressions are not necessarily shorter than generator functions, but you can inline them into other code, just like you can inline list comprehensions
          - So instead of making a whole function just to make a lazy iterable, **(click)** you can write a single expression
          - I do want to note that this example of counting from 1 to 10 is silly and it's very contrived... we're going to look at a couple more realistic examples in a bit
          - But first... let's talk about all these fancy words I've been using
          - TODO highlight things while saying:
            -  Generator functions and generator expressions are a special syntax for creating iterators in Python. 
            - this is a generator function (because of that yield statement) and this is a generator expression
            - calling a generator function or evaluating a generator expression will give you a generator object: which is an iterator, which is a lazy single-use iterable
        </aside>
      </section>

      <section>
        <h3>How to make iterators</h3>
        <ol>
          <li class="fragment" data-fragment-index=1>Write a generator function <span class="fragment" data-fragment-index=3>(calling it returns an iterator)</span></li>
          <li class="fragment" data-fragment-index=2>Make a generator expression <span class="fragment" data-fragment-index=4>(which makes an iterator)</span></li>
          <li class="fragment" data-fragment-index=5><span class="fragment strike" data-fragment-index=6>Make an iterator class</span></li>
        </ol>
        <aside class="notes" data-markdown>
          - So to make an iterator, a lazy iterable, that computes its next item *as* you loop over it...
          - You can either make a generator function...
          - Or a generator expression
          - Because when you call a generator function, you get a generator object back
          - And right when Python evaluates a generator expression, a generator object is made
          - And generator objects *are* iterators... the same way file objects are iterators
          - Technically there is another way to make your own iterator...
          - By making an iterator class... but those are complicated, kind of hard to read, and there's very little unique benefit to them... so we're not going to do that
          - You can think of generator functions and generator expressions as the *easiest way* to make your own custom lazy iterable in Python
          - Great... so we can make iterators by making generators, but once we've got an iterator... what do we do with it?
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h2>How are iterators used?</h2>
        <aside class="notes" data-markdown>
          - We already know the obvious thing to do with an iterator...
        </aside>
      </section>

      <section>
        <h3>Looping over iterators</h3>
        <pre class="python fragment"><code data-trim data-noescape>
squares = (n**2 for n in range(1000))
<span class="fragment">total = 0
for n in squares:
    total += n</span>
        </code></pre>
        <pre class="python fragment"><code data-trim data-noescape>
squares = (n**2 for n in range(1000))
total = sum(squares)
        </code></pre>
        <aside class="notes" data-markdown>
          - Loop over it.
          - We loop over it and do something with each of the things inside it
          - So if we have an iterator of squares of numbers
          - We could add up all those squares by loop with a `for` loop and adding as we go
          - Or we could delegate this work to Python's `sum` function, which will do the looping and the adding for us
          - Regardless of how we do it: the one thing this iterator will ultimately be used for is being looped over
          - But there is one thing we could do with an iterator *before* we loop over it...
        </aside>
      </section>

      <section>
        <h3>Wrapping iterators in iterators</h3>
        <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
<span class="fragment" data-fragment-index=2><span class="fragment bold-current" data-fragment-index=9>squares</span> = (n**2 for n in <span class="fragment bold-current" data-fragment-index=10>range(1000)</span>)
</span><span class="fragment" data-fragment-index=3><span class="fragment bold-current" data-fragment-index=7>palindromic_squares</span> = (
    n
    for n in <span class="fragment bold-current" data-fragment-index=9>squares</span>
    if str(n) == str(n)[::-1]  <span class="fragment" data-fragment-index=4># digits make a palindrome (ex: 464)</span>
)</span>
</span><span class="fragment" data-fragment-index=5><span class="fragment bold-current" data-fragment-index=7>for n in palindromic_squares</span>:
    if 100 &lt;= n &lt; 1000:  <span class="fragment" data-fragment-index=6># 3 digit numbers</span>
        print(n)</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - We can wrap it in another iterator
          - That iterator we had of squares of numbers...
          - We could take that and wrap *another* generator expression around it
          - This second generator expression is filtering down the squares so that we only have the ones where if you reversed their digits, they'd be the same number
          - When we end up finally looping, to do a bit more filtering and then print out the numbers...
          - ...we'll loop over the *second* generator, not the first
          - As we loop over the second generator... it's going to loop over the first one to get the items it needs
          - And as we loop over that... it's going to loop over that `range` object
          - So we have an iterator wrapped in an iterator
          - Let's look at a slightly more realistic example of iterators wrapped in iterators...
        </aside>
      </section>

      <section>
        <h3>Wrapping iterators in iterators</h3>
        <pre class="python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index=2>import csv
</span><span class="fragment" data-fragment-index=1>with open('expenses.csv') as expenses_file:</span><span class="fragment" data-fragment-index=3>
    <span class="fragment bold-current" data-fragment-index=5><span class="fragment bold-current" data-fragment-index=14>expense_rows</span></span> = <span class="fragment bold-current" data-fragment-index=5><span class="fragment bold-current" data-fragment-index=13>csv.reader</span></span>(<span class="fragment bold-current" data-fragment-index=4><span class="fragment bold-current" data-fragment-index=12>expenses_file</span></span>)</span>
    <span class="fragment" data-fragment-index=10>travel_costs = <span class="fragment bold-current" data-fragment-index=15>sum</span>(</span><span class="fragment bold-current" data-fragment-index=14><span class="fragment" data-fragment-index=6><span class="fragment fade-out" data-fragment-index=18>(</span>
        <span class="fragment" data-fragment-index=9>float(cost)</span>
        <span class="fragment" data-fragment-index=7>for date, merchant, cost, category in expense_rows</span>
        <span class="fragment" data-fragment-index=8>if category == 'travel'</span>
    <span class="fragment fade-out" data-fragment-index=18>)</span></span></span><span class="fragment" data-fragment-index=10>)</span><span class="fragment" data-fragment-index=16></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - We're going to read a CSV file of business expenses...
          - We'll import Python's `csv` module to help us parse it
          - At this point we have a file object, which is an iterator, and we pass it to `csv.reader`, which is also going to return an iterator... so no looping has happened yet
          - We're going to take this `expenses_row` iterator...
          - And wrap a generator expression around it
          - This generator will unpack the columns from each row, grab only the travel expense rows, and then take the cost and convert it a floating point number
          - And then we'll take that whole generator expression, and pass it to the `sum` function
          - So we have an iterator, wrapped in another iterator, wrapped in another iterator...
          - And no looping happens until the `sum` function starts looping over that outermost iterator: that generator expression that we pass to it
          - By the way... passing a generator expression straight into another function, like that `sum` function, is such a common thing to do, that the Python core developers made it so we can drop that extra set of parenthesis, kind of visually merging the generator expression with the function call
          - TODO have slide after this talking about how it's hard to make a good analogy about how iterators work but that they're similarity matroyshka dolls or to Unix pipes or ... a sort of lazy looping pipeline
        </aside>
      </section>

      <section>
        <h2>What do you do with iterators?</h2>
        <ol>
          <li class="fragment" data-fragment-index=1><span class="fragment bold-current" data-fragment-index=4>Wrap another iterator around them</span> <span class="fragment" data-fragment-index=5>by
              <ul>
                <li>passing them to a generator function</li>
                <li class="fragment" data-fragment-index=6>creating a generator expression</li>
                <li class="fragment" data-fragment-index=7>calling another iterator-returning function</li>
              </ul>
          </li>
          <li class="fragment" data-fragment-index=2><span class="fragment bold-current" data-fragment-index=8>Loop over them<span class="fragment" data-fragment-index=3>, but only once</span></span>
            <ul>
              <li class="fragment" data-fragment-index=9>writing a <code>for</code> loop <span class="fragment" data-fragment-index=10>or a list comprehension</span></li>
              <li class="fragment" data-fragment-index=11>calling another function that will do the looping</li>
            </ul>
          </li>
        </ol>
        <aside class="notes" data-markdown>
          - TODO before this show heads inside heads inside heads image or dolls inside dolls or something
          - So there are two general things you can *do* with an iterator...
          - You can wrap another iterator around them, that does a little bit more work incrementally
          - And you can do that as many times as you'd like
          - But the one thing you'll always end up doing with the outermost iterator... is looping over it
          - ... But only once. Because once you've looped all the way through an iterator, it's exhausted
          - There are 3 ways to wrap around an iterator...
          - You can either write a generator function that you'll pass your iterator to
          - Or you can write a generator expression that you'll use to loop over it
          - Or you can call some other function that'll accept an iterator, do some work, and return another iterator... like the `csv.reader` function or the built-in `enumerate` function do
          - There are also a couple ways ways to loop over iterator...
          - The obvious way is to write a `for` loop
          - But you could also write a list comprehension
          - Or call some other function that'll do the looping for you... like the `sum` function
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h2 class="fragment">Utility functions for iterators</h2>
        <aside class="notes" data-markdown>
          - So we can write our own generators to help us process iterables in steps as we loop over them...
          - And we can make as many steps as we'd like before we end up looping, but wrapping iterators in iterators
          - But while you're figuring out how to accomplish your iterator-wrapping goals, keep in mind that the best generators... are the ones you don't even have to write...
          - Fortunately there are *a lot* of tools built-in to Python and in third party libraries that can help us in writing our lazy looping code
          - TODO discuss how this applies to Django querysets... useful for processing querysets without taking up lots of memory but also discuss iterator() method (iterator method: Django querysets store the entire results of their queries in memory, which is usually great performance-wise, but that can be a problem if you need to process millions of rows)
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
>>> colors = ['pink', 'blue', 'purple']
>>> <span class="fragment">for n, color in enumerate(colors, start=1):
...     print(n, color)
...</span>
<span class="fragment">1 pink</span>
<span class="fragment">2 blue</span>
<span class="fragment">3 purple</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - TODO better speaker notes: we've already seen enumerate!
          - So we've already seen the built-in `enumerate` function
          - This function takes an iterable and returns an iterator which yields tuples containing each of the items in the original iterable along with a number, starting at 0 by default
          - This isn't the only Python built-in that returns an iterator
          - There's also...
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
>>> colors = ['pink', 'green', 'purple', 'blue']
>>> numbers = [2, 1, 3, 4, 7, 11, 18]
>>> <span class="fragment">list(reversed(colors))</span>
<span class="fragment">['blue', 'purple', 'green', 'pink']
>>> </span><span class="fragment">list(zip(numbers, colors))</span>
<span class="fragment">[(2, 'pink'), (1, 'green'), (3, 'purple'), (4, 'blue')]
>>> </span><span class="fragment">any('p' in c for c in colors)</span>
<span class="fragment">True
>>> </span><span class="fragment">all('p' in c for c in colors)</span>
<span class="fragment">False</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - reversed.
          - When you loop over reversed, you'll get all the items in the sequence you give to it, in reverse order.  This doesn't *accept* an iterator because they're not reversible, but it will return a lazy iterator to you
          - There's also the `zip` function, which accepts any number of iterables and returns an iterator that, when you loop over it, will give you tuples of the corresponding items in each iterable
          - There's also the `any` function which was pretty much invented with the idea that you'd always be passing a generator expression to it... it doesn't return an iterator, but instead returns either `True` if any of the values in the iterable given to it are truthy
          - And the `all` function is the other side of `any`: it returns `True` only if all of the items are truthy, and `False` if any of them aren't
          - These are not the only Python built-ins that play nicely in iterator land, but these are some of the most common ones
          - There are two that you might see which I'd personally discourage you from using...
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
>>> colors = ['pink', 'green', 'purple', 'blue']
>>> numbers = [2, 1, 3, 4, 7, 11, 18]
>>> <span class="fragment">tuple(map(lambda n: n**2, numbers))</span>
<span class="fragment">(4, 1, 9, 16, 49, 121, 324)
>>> </span><span class="fragment">tuple(n**2 for n in numbers)</span>
<span class="fragment">(4, 1, 9, 16, 49, 121, 324)
>>> </span><span class="fragment">tuple(filter(lambda n: n % 2 == 1, numbers))</span>
<span class="fragment">(1, 3, 7, 11)
>>> </span><span class="fragment">tuple(n for n in numbers if n % 2 == 1)</span>
<span class="fragment">(1, 3, 7, 11)</span>

        </code></pre>
        <aside class="notes" data-markdown>
          - The `map` function...
          - Which returns an iterator that will evaluate a function over every item in iterable and give you the return values back
          - I don't use this function often because I usually prefer to write a generator expression that does the same thing
          - The `filter` function I also don't use much
          - It gives you just the values that pass a certain condition
          - And it's pretty much the same as a generator expression with a condition on it
          - Which I usually find more readable
          - Moving away from the Python built-ins...
        </aside>
      </section>

      <section>
        <h3 class="fragment">itertools</h3>
        <aside class="notes" data-markdown>
          - ...There are also a lot of iterator helpers in the standard library...
          - A lot of them live in the itertools module
        </aside>
      </section>

      <section>
        <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
>>> colors = ['pink', 'green', 'purple', 'blue']
>>> numbers = [2, 1, 3, 4, 7]
>>> <span class="fragment" data-fragment-index=2>from itertools import chain<span class="fragment" data-fragment-index=5>, zip_longest</span><span class="fragment" data-fragment-index=8>, islice</span><span class="fragment" data-fragment-index=14>, takewhile</span></span>
>>> </span><span class="fragment" data-fragment-index=3>list(chain.from_iterable(zip(numbers, colors)))
</span><span class="fragment" data-fragment-index=4>[2, 'pink', 1, 'green', 3, 'purple', 4, 'blue']
>>> </span><span class="fragment" data-fragment-index=6>list(zip_longest(numbers, colors, fillvalue=''))
</span><span class="fragment" data-fragment-index=7>[(2, 'pink'), (1, 'green'), (3, 'purple'), (4, 'blue'), (7, '')]
>>> </span><span class="fragment" data-fragment-index=9>squares = (n**2 for n in numbers)
>>> </span><span class="fragment" data-fragment-index=10>list(islice(squares, 3))
</span><span class="fragment" data-fragment-index=11>[4, 1, 9]
>>> </span><span class="fragment" data-fragment-index=12>list(squares)
</span><span class="fragment" data-fragment-index=13>[16, 49]
>>> </span><span class="fragment" data-fragment-index=15>list(takewhile(lambda c: len(c) <= 5, colors))
</span><span class="fragment" data-fragment-index=16>['pink', 'green']</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - There's chain, which has a `from_iterable` attribute which is useful for flattening an iterable of iterables one level deep...
          - So when we saw before that `zip` gave us a list of tuples... `chain.from_iterable` gives us a list with the tuples unpacked into individual items
          - Also in itertools, and related to zip, there's `zip_longest`...
          - The `zip_longest` function works kind of like `zip`, except it stops and the longest iterable, not the shortest one
          - There's also `islice`, which solves a very specific problem...
          - If you have an iterator, say this `squares` generator object...
          - And you try to slice it to grab the first 3 items, you'll get an error (TODO show slicing failing)
          - Because you can't slice iterators: the only thing you can do with them is loop over them
          - So `islice` is handy for grabbing the first `n` values from an iterator and then stopping
          - So if kept looping after using `islice`, we'd see the iterator wasn't fully exhausted
          - One of my favorite things in itertools, which I don't see used often, is `takewhile`
          - `takewhile` accepts a condition and an iterable and it'll give give you all the items in that iterable until that condition is False for one of the items
          - So here we're asking for colors with a length less than 5... it stops just before purple because it has a length greater than 4... so we never even get to blue
          - You can think of `takewhile` as an alternative to writing a `for` loop with a `break` statement in it
          <!--
          - TODO shorten explanations above?
            - And there's takewhile which is like filter except it stops after it hits something that doesn't match the condition: so it's an alternative to writing a `for` loop with a break statement based on some condition
            - And there's `chain.from_iterable` which can flatten a two-level deep nested iterable
            - And there's `cycle` which just infinitely cycles through the values you give to it
          -->
        </aside>
      </section>

      <section>
        <h3 class="fragment">more-itertools</h3>
        <h3 class="fragment">boltons<span class="fragment">.iterutils</span></h3>
        <aside class="notes" data-markdown>
          - There are also a number of third-party libraries that try to augment the functions that are in the itertools module
          - One of them is just called more-itertools
          - And another one is called `boltons`
          - We're going to look at a submodule of `boltons` called `iterutils`, which is is full of tools for helping you iterate, both lazily and otherwise
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
from boltons.iterutils import chunked_iter

with open('logs.txt') as log_file:
    for lines in <span class="fragment bold-current">chunked_iter(log_file, 100)</span>:
        print(*lines, sep='')
        <span class="fragment bold-current">input("Hit Enter to see the next 100 lines...\n")</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - One of the boltons.itertools functions is called chunked_iter
          - It'll help you you loop over an iterable n items at a time
          - So here we're looping over a file, 100 lines at a time
          - And we're prompting the user in-between to ask if they'd like to see more lines
          - Another tool from boltons is...
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
from boltons.iterutils import split_iter

with open('writing.txt') as text_file:
    for lines in <span class="fragment bold-current">split_iter(text_file, <span class="fragment bold-current">sep='\n'</span>)</span>:
        paragraph = "".join(lines)
        print(f"&lt;p>\n{paragraph}&lt;/p>")
        </code></pre>
        <aside class="notes" data-markdown>
          - `split_iter`, which is 
          - `split_iter` also allows you to loop over items in groups, but instead of grouping by the number of items it splits up the groups based on delimiter values you give it
          - So here we're looping paragraph-by-paragraph, because our delimiter is a line with single newline character, which is an empty line
        </aside>
      </section>

      <!-- TODO slide here with built-ins, itertools, third-party libraries like more-itertools or boltons -->

      </section>

      <section>

      <section>
        <h2>Problem 1: Revisited</h2>
        <h3 class="fragment">Find first 10 errors from yesterday</h3>
        <aside class="notes" data-markdown>
          - Let's finally revisit the first problem we saw at the beginning of this talk
          - That was some code that looped over a log file to find the first 10 errors that occurred yesterday
        </aside>
      </section>

      <section data-transition="slide-in fade-out">
        <pre class="python"><code data-trim data-noescape>
from datetime import date, timedelta


yesterday = date.today() - timedelta(1)

with open('log.txt') as log_file:
    <span class="fragment bold-current" data-fragment-index=1>i = 0</span>
    for line in log_file:
        if str(yesterday) in line and 'error' in line.lower():
            <span class="fragment bold-current" data-fragment-index=1>i += 1</span>

            if i &lt;= 10:
                print(line, end='')

            else:
                print('[...]')
                break
        </code></pre>
        <aside class="notes" data-markdown>
          - You can see we're counting upward as we work with lines in this file
          - Often we can use `enumerate` to count upward for us, but we can't do that here because we only care about *some* of the lines: just the ones with errors from yesterday
          - If we could make a lazy iterable out of *just* those lines, we could reach for `enumerate` to count for us
          - We can do that...
        </aside>
      </section>

      <section data-transition="fade-in fade-out">
        <pre class="python"><code data-trim data-noescape>
from datetime import date, timedelta


yesterday = date.today() - timedelta(1)

with open('log.txt') as log_file:
    <span class="fragment" data-fragment-index=3>error_lines = </span><span class="fragment" data-fragment-index=1>(</span><span class="fragment" data-fragment-index=3>
        line</span>
        <span class="fragment" data-fragment-index=1>for line in log_file</span>
        <span class="fragment" data-fragment-index=2>if str(yesterday) in line and 'error' in line.lower()</span>
    <span class="fragment" data-fragment-index=1>)</span>
    <span class="fragment" data-fragment-index=4><span class="fragment bold-current" data-fragment-index=6>for i, line in enumerate(error_lines):
        if i == 10:
            break
        print(line, end='')</span></span>
    <span class="fragment" data-fragment-index=5>if next(error_lines, ''):
        print('[...]')</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - By making a generator expression...
          - Which will eventually loop over our file line-by-line
          - And filtering our lines down...
          - ...to just the ones we care about: the error lines
          - After that we've got a lazy iterable, a generator, that we could pass to `enumerate`, and then loop over
          - This way we can break on the tenth line
          - And if there's another line left, we'll print out those ellipsis to signify that there are even more lines after those 10
          - You might might also notice that this loop here is really asking a specific question: it's looking for *just the first 10 lines* in our iterator
          - We can do the same thing with `islice` from Python's `itertools` module
        </aside>
      </section>

      <section data-transition="fade-in fade-out">
        <pre class="python"><code data-trim data-noescape>
from datetime import date, timedelta
from itertools import islice

yesterday = date.today() - timedelta(1)

with open('log.txt') as log_file:
    error_lines = (
        line
        for line in log_file
        if str(yesterday) in line and 'error' in line.lower()
    )

    for line in islice(error_lines, 10):
        print(line, end='')

    if next(error_lines, ''):
        print('[...]')


        </code></pre>
        <aside class="notes" data-markdown>
          - I find this more readable than what we started with...
          - Regardless of whether you find it more readable to break this particular big loop into smaller lazies loops, you should try this process out yourself on your own code
          - You can write loops as one big piece, as lots of little iterators wrapper around each other, or as something in-between: it's up to you
          - ...
          - TODO transition into problem 2
        </aside>
      </section>

      <section data-transition="fade-in slide-out">
        <pre class="python"><code data-trim data-noescape>
from datetime import date, timedelta


yesterday = date.today() - timedelta(1)

with open('log.txt') as log_file:
    i = 0
    for line in log_file:
        if str(yesterday) in line and 'error' in line.lower():
            i += 1
            if i &lt;= 10:
                print(line, end='')
            else:
                print('[...]')
                break<span>

        </span></code></pre>
        <aside class="notes" data-markdown>
          - But you may not...
          - *(click to go back)*
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h2>Problem 2: Revisited</h2>
        <h3 class="fragment">Find logged errors (with context)</h3>
        <aside class="notes" data-markdown>
          - So problem 2 was finding error lines in addition to the line just before the error and the line just after the error
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
with open('logs.txt') as log_file:
    <span class="fragment bold-current" data-fragment-index=3>prev = line = ''</span>
    <span class="fragment bold-current" data-fragment-index=2>for next in log_file:</span>
        <span class="fragment bold-current" data-fragment-index=10><span class="fragment bold-current" data-fragment-index=4>next = next.rstrip('\n')</span></span>
        <span class="fragment bold-current" data-fragment-index=5>if line and 'error' in line.lower():</span>
            <span class="fragment bold-current" data-fragment-index=7>print(prev, line, next, sep='\n')</span>
        <span class="fragment bold-current" data-fragment-index=3>prev, line = line, next</span><span class="fragment bold-current" data-fragment-index=9></span>
    <span class="fragment bold-current" data-fragment-index=8>if line and 'error' in line.lower():
        print(prev, line, sep='\n')</span>
        </code></pre>
        <aside class="notes" data-markdown>
          - This was our code for this...
          - We're looping over a file here...
          - And keeping track of the previous, current, and next line
          - Removing newlines from our lines
          - Making sure we're on an error line
          - And if we are, we print out the previous, current, and next line
          - And then afterward we have to check whether the last line also had an error... because the logic to keep track of the previous, current, and next line kind of required that
          - ...
          - This is complicated
          - We're going to start with a very small change...
          - Taking this newline stripping, and moving that into its iterator...
        </aside>
      </section>

      <section>
        <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
def strip_newlines(lines):
    for line in lines:
        yield line.rstrip('\n')
        </code></pre>
        <pre class="python fragment" data-fragment-index=2><code data-trim data-noescape>
with open('logs.txt') as log_file:
    <span class="fragment bold-current" data-fragment-index=4>prev = line = ''</span>
    for <span class="fragment bold-current" data-fragment-index=4>next</span> in <span class="fragment bold-current" data-fragment-index=3>strip_newlines(log_file)</span>:
        if line and 'error' in line.lower():
            print(prev, line, next, sep='\n')
        <span class="fragment bold-current" data-fragment-index=4>prev, line = line, next</span>
    if <span class="fragment bold-current" data-fragment-index=4>line</span> and 'error' in line.lower():
        print(<span class="fragment bold-current" data-fragment-index=4>prev</span>, line, sep='\n')
        </code></pre>
        <aside class="notes" data-markdown>
          - This `strip_newlines` generator function...
          - Then we can modify our code to wrap our file object in this `strip_newlines` generator function, wrapping one iterator in another iterator, that does a little bit of work as we loop over it...
          - This didn't really help much, but it's going to allow us to simplify even more things
          - The next thing we'll simplify will be all of this "previous, current, next line"-handling logic
          - We'll make a generator function, that will take our lines and yield out the line before each one and the line after each one
        </aside>
      </section>

      <section>
        <pre class="python"><code data-trim data-noescape>
def around(iterable, fillvalue=''):
    """Yield (prev, item, next) for each item in iterable."""
    before = current = fillvalue
    for after in iterable:
        if current is not fillvalue:
            <span class="fragment bold-current" data-fragment-index=1>yield (before, current, after)</span>
        before, current = current, after
    if current is not fillvalue:
        <span class="fragment bold-current" data-fragment-index=2>yield (before, current, fillvalue)</span>
        </code></pre>
        <pre class="python fragment" data-fragment-index=3><code data-trim data-noescape>
with open('logs.txt') as log_file:
    <span class="fragment bold-current" data-fragment-index=9>for prev, line, next in</span> <span class="fragment bold-current" data-fragment-index=7>around</span>(<span class="fragment bold-current" data-fragment-index=6>strip_newlines</span>(<span class="fragment bold-current" data-fragment-index=5>log_file</span>)):
        if 'error' in line.lower():
            print(prev, line, next, sep='\n')
        </code></pre><span class="fragment" data-fragment-index=10></span>
        </code></pre>
        <aside class="notes" data-markdown>
          - This `around` generator function yields out the previous, current, and next line over and over
          - And handles that special case for the last line, the same way we did before
          - This function isn't pretty, but *using it* will make our `for` loop a lot more readable
          - We're now taking a file object, which is an iterator...
          - And wrapping that in our `strip_newlines` generator function, which also returns an iterator...
          - And we're wrapping that iterator in our `around` generator function, which also returns an iterator...
          - But no work will be done, until we start *looping* over that outer iterator
          - Python doesn't care if our log file is 10 lines or 10 million lines here: because these iterators are all lazy, we're always considering only 3 lines at a time... nothing else is stored in memory
          - ...So after all of this...
        </aside>
      </section>

      <section data-transition="slide-in fade-out">
        <pre class="python" data-fragment-index=3><code data-trim data-noescape>
def around(iterable):
    """Yield (prev, item, next) for each item in iterable."""
    before = current = None
    for after in iterable:
        if current is not None:
            yield (before, current, after)
        before, current = current, after
    if current is not None:
        yield (before, current, None)

def strip_newlines(lines):
    for line in lines:
        yield line.rstrip('\n')

with open('logs.txt') as log_file:
    for prev, line, next in around(strip_newlines(log_file)):
        if 'error' in line.lower():
            print(prev, line, next, sep='\n')
        </code></pre>
        <aside class="notes" data-markdown>
          - We'll end up with two new generator functions and a much shorter `for` loop
          - We've *moved* the logic that was in our loop into these generators
          - Our code definitely isn't *shorter* at this point, but someone reading that `for` loop is probably going to understand what the code *does* better because our code is more *descriptive*: it actually *describes* what's going on
          - If we did want to make these even shorter though... there's actually a tool that's in both the `boltons` and `more-itertools` libraries that could help us make that `around` generator function much simpler...
        </aside>
      </section>

      <section data-transition="fade-in fade-out">
        <pre class="python" data-fragment-index=3><code data-trim data-noescape>
from itertools import chain
from boltons.iterutils import windowed_iter

def around(iterable):
    """Yield (prev, item, next) for each item in iterable."""
    return windowed_iter(chain([''], iterable, ['']), size=3)

def strip_newlines(lines):
    for line in lines:
        yield line.rstrip('\n')

with open('logs.txt') as log_file:
    for prev, line, next in around(strip_newlines(log_file)):
        if 'error' in line.lower():
            print(prev, line, next, sep='\n')
        </code></pre>
        <aside class="notes" data-markdown>
          - it's called `windowed` in more-itertools and `windowed_iter` in boltons
          - It allows us to loop with a sliding window of 3 items at a time... which is pretty close to what we were already doing with `around`
          - ...
          - I find what we ended up with here, a lot more readable...
        </aside>
      </section>

      <section data-transition="fade-in fade-out">
        <pre class="python" data-fragment-index=3><code data-trim data-noescape>
with open('logs.txt') as log_file:
    prev = line = ''
    for next in log_file:
        next = next.rstrip('\n')
        if line and 'error' in line.lower():
            print(prev, line, next, sep='\n')
        prev, line = line, next
    if line and 'error' in line.lower():
        print(prev, line, sep='\n')
        </code></pre>
        <aside class="notes" data-markdown>
          - than what we started with.
          - This is one big loop that has lots of logic hidden within it.
          - ...
        </aside>
      </section>

      <section data-transition="fade-in slide-out">
        <pre class="python" data-fragment-index=3><code data-trim data-noescape>
from itertools import chain
from boltons.iterutils import windowed_iter

def around(iterable):
    """Yield (prev, item, next) for each item in iterable."""
    return windowed_iter(chain([''], iterable, ['']), size=3)

def strip_newlines(lines):
    for line in lines:
        yield line.rstrip('\n')

with open('logs.txt') as log_file:
    for prev, line, next in around(strip_newlines(log_file)):
        if 'error' in line.lower():
            print(prev, line, next, sep='\n')
        </code></pre>
        <aside class="notes" data-markdown>
          - and *this* is one small loop with a couple lazy looping helper functions to make our life a little bit easier
          - TODO maybe move the "even if you don't find this better..." here?
        </aside>
      </section>

      </section>

      <section>

      <section>
        <h2>Words are hard</h2>
        <aside class="notes" data-markdown>
          - So... I have some bad news
          - The way I used the words "generator" in this talk isn't universal
          - Here's the way that *I* defined these terms...
        </aside>
      </section>

      <section data-transition="fade-in slide-out">
        <ul>
          <li class="fragment" data-fragment-index=0><strong class="fragment underline-current" data-fragment-index=8>Iterator</strong>: lazy single-use iterable</li>
          <li class="fragment" data-fragment-index=1><strong class="fragment underline-current" data-fragment-index=5>Generator function</strong>: a syntax for easily creating iterators</li>
          <li class="fragment" data-fragment-index=2><strong class="fragment underline-current" data-fragment-index=6>Generator expression</strong>: comprehension which returns a generator instead of a list</li>
          <li class="fragment" data-fragment-index=3><strong class="fragment underline-current" data-fragment-index=7>Generator object</strong> (aka <span class="fragment underline-current" data-fragment-index=4>generator</span>): an iterator created from a generator function (or a generator expression)</li>
          <span class="fragment" data-fragment-index=9></span>
        </ul>
        <aside class="notes" data-markdown>
          - An **iterator** is a lazy single-use iterable that computes its *next* item and give it back to you as you loop over it
          - A **generator function** is a special syntax that we can use for making a function which returns an iterator
          - A **generator expression** is a special syntax, that looks like a list comprehension, and when you make one of these expressions you'll get an iterator back
          - The type of iterator you get back from each of these is called a **generator object** or just **a generator**
          - When you call a generator function or evaluate a generator expression, you *get* one of these generator objects
          - And generator objects are a type of **iterator**... they're basically the *easiest way* to make an iterator
          - So that's how *I* define these terms...
          - But the Python documentation disagrees with me
          - Then apologize and note that the Python documentation calls these by different names, ones which I both disagree with and don't hear used quite as frequently by most Python programmers
        </aside>
      </section>

      <section data-background="#ffffff">
        <table class="no-style no-padding top-aligned">
          <tbody>
            <tr>
              <td class="fragment"><small><nobr><strong>generator function</strong></nobr></small></td>
              <td class="fragment"><img src="generator-term.png" class="no-style"></td>
            </tr>
            <tr>
              <td class="fragment">
                <small><strong><nobr>generator object</nobr></small></strong>
                <small class="fragment"><strong><nobr>generator</nobr></small></strong>
              </td>
              <td class="fragment"><img src="generator-iterator-term.png" class="no-style"></td>
            </tr>
            <tr>
              <td class="fragment"><small><strong><nobr>generator expression</nobr></strong></small></td>
              <td class="fragment"><img src="generator-expression-term.png" class="no-style"></td>
            </tr>
            <tr class="fragment">
              <td colspan=2><small>"Calling a generator function returns a generator" - Luciano Ramalho in Fluent Python (page 429)</small></td>
            </tr>
          </tbody>
        </table>
        <aside class="notes" data-markdown>
          - TODO that word "generator" is the ambiguous one
            - I've never heard anyone actually *use* the phrase generator iterator outside of the Python documentation, though I *have* heard people refer to generator functions as *generators*
          - TODO maybe talk about how when we have an object of type list I refer to that as "a list" and an object of type function I refer to as a "function"
          - TODO Luciano in Fluent Python (page 429): "Calling a generator function returns a generator."
        </aside>
      </section>

      </section>

      <section>
        <h2>Recap</h2>
        <ul>
          <li class="fragment">Iteration helpers can help <strong>break up large loops</strong> into smaller chunks</li>
          <li class="fragment">Smaller loops can make your code <strong>more readable</strong> and <strong>more maintainable</strong></li>
          <li class="fragment">Know how to use iteration helpers<span class="fragment">, where to find them</span><span class="fragment">, and how to make your own using generators</span></li>
        </ul>
        <aside class="notes" data-markdown>
          - Regardless of whether you're inventing your own iteration helpers or reaching for helpers written by others, using iteration helpers can really improve the readability of your code **(click)**
          - It's similar to splitting one big function up into a couple little functions
          - But instead we're using iterators generator functions to move *generic* logic outside of your loops, to make our loops cleaner and easier to understand
          - This can make our code more descriptive and easier to understand **(click)**
          - So learn how to *use* iteration helpers **(click)**
          - ...where to *find* iteration helpers within Python itself and in third-party libraries **(click)**
          - ...and how to write your own helpers with generator functions and generator expressions **(click)**

          - TODO Maybe a table showing helpers and their use
            - Using with_previous/with_next/window/pairwise-like helpers to remove “side cars”
            - Using any/all instead of early break/return (is_prime)
            - Using dropwhile/takewhile instead of early break (trim function)
            - Using next instead of an early return/break
            - Using islice instead of manual loop-and-append-and-break or manual next-ing
          - Iterators allow for more descriptive code
        </aside>
      </section>

      <section data-background-image="lazy-looping-tutorial.png" class="no-controls">
        <div class="fragment" style="background: rgba(238, 238, 238, 0.9); ">
        <h1>Lazy Looping in Python</h1>
        <h3>Making and Using Generators and Iterators</h3>
        </div>
        <aside class="notes" data-markdown>
          - And if you want to dive even deeper, I gave a 3 hour tutorial on lazy looping at PyCon this year
        </aside>
      </section>

      <!--
      <section>
        <h2>Conclusion</h2>
        <ul>
          <li class="fragment">Iterables: objects which can provide iterators</li>
          <li class="fragment">Iterators: objects which can give you their "next" item repeatedly</li>
          <li class="fragment">Iterators allow for lazy iterables and lazy iteration</li>
          <li class="fragment">Generators allow for an easy way to make your own lazy iterable</li>
          <li class="fragment">Lazy iterables can allow us to write more descriptive code</li>
        </ul>
        <aside class="notes" data-markdown>
          - TODO XXX Conclusion
          - Iterables give iterators and iterators give each item individually
          - Iterators are the backbone of looping in Python
          - Iterators also empower lazy iteration and working directly with iterators can allow you to write more flexible code
          - Iterators allow you to write your code in a different way
        </aside>
      </section>
      -->

      <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
        <h2>Need help getting your team <nobr>up to speed on Python?</nobr></h2>
        <h3>
          <strong>Trey Hunner</strong><br>
          <small>Python &amp; Django Team Trainer</small>
        </h3>
        <p>
          <small>
            Contact me: <a href="mailto:&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;">&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;</a>
          </small>
        </p>
        <p>
        <a href="http://truthful.technology"><img src="logo.svg" class="no-style logo"></a>
        <a href="http://pythonmorsels.com"><img src="python-morsels-logo.svg" class="no-style logo"></a>
        </p>
          <p><small>
            <a href="https://commons.wikimedia.org/wiki/File:Hand_tally_and_knitting_row_counter_007.jpg">Tally counter image &copy; Linda Spashett, CC BY</a><br>
            <a href="https://www.flickr.com/photos/30223382@N06/4151828376">Hello Kitty PEZ image &copy; Deborah Austin, CC BY</a><br>
          </small></p>
        <aside class="notes" data-markdown>
          - Thank you
        </aside>
      </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/truthful.js"></script>


    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
